{"version":3,"file":"chartjs-plugin-annotation.min.js","sources":["../src/events.js","../src/helpers.js","../src/types/box.js","../src/types/line.js","../src/types/ellipse.js","../src/types/point.js","../src/annotation.js","../src/index.js"],"sourcesContent":["import {distanceBetweenPoints, callback as callHandler} from 'chart.js/helpers';\n\nconst clickHooks = ['click', 'dblclick'];\nconst moveHooks = ['enter', 'leave'];\nexport const hooks = clickHooks.concat(moveHooks);\n\nexport function updateListeners(chart, state, options) {\n  const annotations = state.annotations || [];\n  state.listened = false;\n  state.moveListened = false;\n\n  hooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.listened = true;\n      state.listeners[hook] = options[hook];\n    }\n  });\n  moveHooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.moveListened = true;\n    }\n  });\n\n  if (!state.listened || !state.moveListened) {\n    annotations.forEach(scope => {\n      if (!state.listened) {\n        clickHooks.forEach(hook => {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n          }\n        });\n      }\n      if (!state.moveListened) {\n        moveHooks.forEach(hook => {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n            state.moveListened = true;\n          }\n        });\n      }\n    });\n  }\n}\n\nexport function handleEvent(chart, state, event, options) {\n  if (state.listened) {\n    switch (event.type) {\n    case 'mousemove':\n    case 'mouseout':\n      handleMoveEvents(chart, state, event);\n      break;\n    case 'click':\n      handleClickEvents(chart, state, event, options);\n      break;\n    default:\n    }\n  }\n}\n\nfunction handleMoveEvents(chart, state, event) {\n  if (!state.moveListened) {\n    return;\n  }\n\n  let element;\n\n  if (event.type === 'mousemove') {\n    element = getNearestItem(state.elements, event);\n  }\n\n  const previous = state.hovered;\n  state.hovered = element;\n\n  dispatchMoveEvents(chart, state, previous, element);\n}\n\nfunction dispatchMoveEvents(chart, state, previous, element) {\n  if (previous && previous !== element) {\n    dispatchEvent(chart, state, previous.options.leave || state.listeners.leave, previous);\n  }\n  if (element && element !== previous) {\n    dispatchEvent(chart, state, element.options.enter || state.listeners.enter, element);\n  }\n}\n\nfunction handleClickEvents(chart, state, event, options) {\n  const listeners = state.listeners;\n  const element = getNearestItem(state.elements, event);\n  if (element) {\n    const elOpts = element.options;\n    const dblclick = elOpts.dblclick || listeners.dblclick;\n    const click = elOpts.click || listeners.click;\n    if (element.clickTimeout) {\n      // 2nd click before timeout, so its a double click\n      clearTimeout(element.clickTimeout);\n      delete element.clickTimeout;\n      dispatchEvent(chart, state, dblclick, element);\n    } else if (dblclick) {\n      // if there is a dblclick handler, wait for dblClickSpeed ms before deciding its a click\n      element.clickTimeout = setTimeout(() => {\n        delete element.clickTimeout;\n        dispatchEvent(chart, state, click, element);\n      }, options.dblClickSpeed);\n    } else {\n      // no double click handler, just call the click handler directly\n      dispatchEvent(chart, state, click, element);\n    }\n  }\n}\n\nfunction dispatchEvent(chart, _state, handler, element) {\n  callHandler(handler, [{chart, element}]);\n}\n\nfunction getNearestItem(elements, position) {\n  let minDistance = Number.POSITIVE_INFINITY;\n\n  return elements\n    .filter((element) => element.options.display && element.inRange(position.x, position.y))\n    .reduce((nearestItems, element) => {\n      const center = element.getCenterPoint();\n      const distance = distanceBetweenPoints(position, center);\n\n      if (distance < minDistance) {\n        nearestItems = [element];\n        minDistance = distance;\n      } else if (distance === minDistance) {\n        // Can have multiple items at the same distance in which case we sort by size\n        nearestItems.push(element);\n      }\n\n      return nearestItems;\n    }, [])\n    .sort((a, b) => a._index - b._index)\n    .slice(0, 1)[0]; // return only the top item\n}\n","import {isFinite} from 'chart.js/helpers';\n\nconst PI = Math.PI;\nconst HALF_PI = PI / 2;\n\nexport function scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? scale.getPixelForValue(value) : fallback;\n}\n\n/**\n * Creates a \"path\" for a rectangle with rounded corners at position (x, y) with a\n * given size (width, height) and the same `radius` for all corners.\n * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.\n * @param {number} x - The x axis of the coordinate for the rectangle starting point.\n * @param {number} y - The y axis of the coordinate for the rectangle starting point.\n * @param {number} width - The rectangle's width.\n * @param {number} height - The rectangle's height.\n * @param {number} radius - The rounded amount (in pixels) for the four corners.\n * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?\n */\nexport function roundedRect(ctx, x, y, width, height, radius) {\n  ctx.beginPath();\n  if (radius) {\n    const r = Math.min(radius, height / 2, width / 2);\n    const left = x + r;\n    const top = y + r;\n    const right = x + width - r;\n    const bottom = y + height - r;\n\n    ctx.moveTo(x, top);\n    if (left < right && top < bottom) {\n      ctx.arc(left, top, r, -PI, -HALF_PI);\n      ctx.arc(right, top, r, -HALF_PI, 0);\n      ctx.arc(right, bottom, r, 0, HALF_PI);\n      ctx.arc(left, bottom, r, HALF_PI, PI);\n    } else if (left < right) {\n      ctx.moveTo(left, y);\n      ctx.arc(right, top, r, -HALF_PI, HALF_PI);\n      ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);\n    } else if (top < bottom) {\n      ctx.arc(left, top, r, -PI, 0);\n      ctx.arc(left, bottom, r, 0, PI);\n    } else {\n      ctx.arc(left, top, r, -PI, PI);\n    }\n    ctx.closePath();\n    ctx.moveTo(x, y);\n  } else {\n    ctx.rect(x, y, width, height);\n  }\n}\n\n/**\n * Rotate a `point` relative to `center` point by `angle`\n * @param {{x: number, y: number}} point - the point to rotate\n * @param {{x: number, y: number}} center - center point for rotation\n * @param {number} angle - angle for rotation, in radians\n * @returns {{x: number, y: number}} rotated point\n */\nexport function rotated(point, center, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  var cx = center.x;\n  var cy = center.y;\n\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\n","import {Element} from 'chart.js';\nimport {scaleValue, roundedRect} from '../helpers';\n\nexport default class BoxAnnotation extends Element {\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const {x, y, width, height} = this.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\n\n    return mouseX >= x &&\n\t\t\tmouseX <= x + width &&\n\t\t\tmouseY >= y &&\n\t\t\tmouseY <= y + height;\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {x, y, width, height} = this.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\n    return {\n      x: x + width / 2,\n      y: y + height / 2\n    };\n  }\n\n  draw(ctx) {\n    const {x, y, width, height, options} = this;\n\n    ctx.save();\n\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n\n    roundedRect(ctx, x, y, width, height, options.cornerRadius);\n    ctx.fill();\n\n    // If no border, don't draw it\n    if (options.borderWidth) {\n      ctx.stroke();\n    }\n\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const xScale = chart.scales[options.xScaleID];\n    const yScale = chart.scales[options.yScaleID];\n    let {top: y, left: x, bottom: y2, right: x2} = chart.chartArea;\n    let min, max;\n\n    if (!xScale && !yScale) {\n      return {options: {}};\n    }\n\n    if (xScale) {\n      min = scaleValue(xScale, options.xMin, x);\n      max = scaleValue(xScale, options.xMax, x2);\n      x = Math.min(min, max);\n      x2 = Math.max(min, max);\n    }\n\n    if (yScale) {\n      min = scaleValue(yScale, options.yMin, y2);\n      max = scaleValue(yScale, options.yMax, y);\n      y = Math.min(min, max);\n      y2 = Math.max(min, max);\n    }\n\n    return {\n      x,\n      y,\n      x2,\n      y2,\n      width: x2 - x,\n      height: y2 - y\n    };\n  }\n}\n\nBoxAnnotation.id = 'boxAnnotation';\n\nBoxAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  cornerRadius: 0,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\n\nBoxAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n","import {Element} from 'chart.js';\nimport {isArray, toFontString, toRadians} from 'chart.js/helpers';\nimport {scaleValue, roundedRect, rotated} from '../helpers';\n\nconst PI = Math.PI;\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\nconst pointInLine = (p1, p2, t) => {\n  t = clamp(t, 0, 1);\n  return {x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y)};\n};\nconst interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\nconst interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\nconst toPercent = (s) => typeof s === 'string' && s.endsWith('%') && parseFloat(s) / 100;\n\nfunction limitPointToArea({x, y}, p2, {top, right, bottom, left}) {\n  if (x < left) {\n    y = p2.x < left ? NaN : interpolateY(left, {x, y}, p2);\n    x = left;\n  }\n  if (x > right) {\n    y = p2.x > right ? NaN : interpolateY(right, {x, y}, p2);\n    x = right;\n  }\n  if (y < top) {\n    x = p2.y < top ? NaN : interpolateX(top, {x, y}, p2);\n    y = top;\n  }\n  if (y > bottom) {\n    x = p2.y > bottom ? NaN : interpolateX(bottom, {x, y}, p2);\n    y = bottom;\n  }\n  return {x, y};\n}\n\nfunction limitLineToArea(p1, p2, area) {\n  const {x, y} = limitPointToArea(p1, p2, area);\n  const {x: x2, y: y2} = limitPointToArea(p2, p1, area);\n  return {x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y)};\n}\n\nexport default class LineAnnotation extends Element {\n  intersects(x, y, epsilon) {\n    epsilon = epsilon || 0.001;\n    const me = this;\n    const p1 = {x: me.x, y: me.y};\n    const p2 = {x: me.x2, y: me.y2};\n    const dy = interpolateY(x, p1, p2);\n    const dx = interpolateX(y, p1, p2);\n    return (\n      (!isFinite(dy) || Math.abs(y - dy) < epsilon) &&\n\t\t\t(!isFinite(dx) || Math.abs(x - dx) < epsilon)\n    );\n  }\n\n  labelIsVisible() {\n    const label = this.options.label;\n    return label && label.enabled && label.content;\n  }\n\n  isOnLabel(mouseX, mouseY) {\n    const {labelRect} = this;\n\n    if (!labelRect) {\n      return false;\n    }\n\n    const {x, y} = rotated({x: mouseX, y: mouseY}, labelRect, -labelRect.rotation);\n    const w2 = labelRect.width / 2;\n    const h2 = labelRect.height / 2;\n    return x >= labelRect.x - w2 && x <= labelRect.x + w2 &&\n      y >= labelRect.y - h2 && y <= labelRect.y + h2;\n  }\n\n  inRange(x, y) {\n    const epsilon = this.options.borderWidth || 1;\n    return this.intersects(x, y, epsilon) || this.isOnLabel(x, y);\n  }\n\n  getCenterPoint() {\n    return {\n      x: (this.x2 + this.x) / 2,\n      y: (this.y2 + this.y) / 2\n    };\n  }\n\n  draw(ctx) {\n    const {x, y, x2, y2, options} = this;\n    ctx.save();\n\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n\n    // Draw\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  drawLabel(ctx, chartArea) {\n    if (this.labelIsVisible()) {\n      ctx.save();\n      drawLabel(ctx, this, chartArea);\n      ctx.restore();\n    }\n  }\n\n  resolveElementProperties(chart, options) {\n    const scale = chart.scales[options.scaleID];\n    let {top: y, left: x, bottom: y2, right: x2} = chart.chartArea;\n    let min, max;\n\n    if (scale) {\n      min = scaleValue(scale, options.value, NaN);\n      max = scaleValue(scale, options.endValue, min);\n      if (scale.isHorizontal()) {\n        x = min;\n        x2 = max;\n      } else {\n        y = min;\n        y2 = max;\n      }\n    } else {\n      const xScale = chart.scales[options.xScaleID];\n      const yScale = chart.scales[options.yScaleID];\n\n      if (xScale) {\n        x = scaleValue(xScale, options.xMin, x);\n        x2 = scaleValue(xScale, options.xMax, x2);\n      }\n\n      if (yScale) {\n        y = scaleValue(yScale, options.yMin, y);\n        y2 = scaleValue(yScale, options.yMax, y2);\n      }\n    }\n    return limitLineToArea({x, y}, {x: x2, y: y2}, chart.chartArea);\n  }\n}\n\nLineAnnotation.id = 'lineAnnotation';\nLineAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderWidth: 2,\n  borderDash: [],\n  borderDashOffset: 0,\n  label: {\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: 'bold',\n      weight: undefined\n    },\n    color: '#fff',\n    xPadding: 6,\n    yPadding: 6,\n    rotation: 0,\n    cornerRadius: 6,\n    position: 'center',\n    xAdjust: 0,\n    yAdjust: 0,\n    textAlign: 'center',\n    enabled: false,\n    content: null\n  },\n  value: undefined,\n  endValue: undefined,\n  scaleID: undefined,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\n\nLineAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\n\nfunction calculateAutoRotation(line) {\n  const {x, y, x2, y2} = line;\n  const rotation = Math.atan2(y2 - y, x2 - x);\n  // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\n  return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;\n}\n\nfunction drawLabel(ctx, line, chartArea) {\n  const label = line.options.label;\n\n  ctx.font = toFontString(label.font);\n\n  const {width, height} = measureLabel(ctx, label);\n  const rect = line.labelRect = calculateLabelPosition(line, width, height, chartArea);\n\n  ctx.translate(rect.x, rect.y);\n  ctx.rotate(rect.rotation);\n\n  ctx.fillStyle = label.backgroundColor;\n  roundedRect(ctx, -(width / 2), -(height / 2), width, height, label.cornerRadius);\n  ctx.fill();\n\n  ctx.fillStyle = label.color;\n  if (isArray(label.content)) {\n    ctx.textAlign = label.textAlign;\n    const x = calculateLabelXAlignment(label, width);\n    let textYPosition = -(height / 2) + label.yPadding;\n    for (let i = 0; i < label.content.length; i++) {\n      ctx.textBaseline = 'top';\n      ctx.fillText(\n        label.content[i],\n        x,\n        textYPosition\n      );\n      textYPosition += label.font.size + label.yPadding;\n    }\n  } else if (label.content instanceof Image) {\n    const x = -(width / 2) + label.xPadding;\n    const y = -(height / 2) + label.yPadding;\n    ctx.drawImage(label.content, x, y, width - (2 * label.xPadding), height - (2 * label.yPadding));\n  } else {\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(label.content, 0, 0);\n  }\n}\n\nfunction calculateLabelXAlignment(label, width) {\n  const {textAlign, xPadding} = label;\n  if (textAlign === 'start') {\n    return -(width / 2) + xPadding;\n  } else if (textAlign === 'end') {\n    return +(width / 2) - xPadding;\n  }\n  return 0;\n}\n\nfunction getImageSize(size, value) {\n  if (typeof value === 'number') {\n    return value;\n  } else if (typeof value === 'string') {\n    return toPercent(value) * size;\n  }\n  return size;\n}\n\nconst widthCache = new Map();\nfunction measureLabel(ctx, label) {\n  const content = label.content;\n  if (content instanceof Image) {\n    return {\n      width: getImageSize(content.width, label.width) + 2 * label.xPadding,\n      height: getImageSize(content.height, label.height) + 2 * label.yPadding\n    };\n  }\n  const lines = isArray(content) ? content : [content];\n  const count = lines.length;\n  let width = 0;\n  for (let i = 0; i < count; i++) {\n    const text = lines[i];\n    if (!widthCache.has(text)) {\n      widthCache.set(text, ctx.measureText(text).width);\n    }\n    width = Math.max(width, widthCache.get(text));\n  }\n  width += 2 * label.xPadding;\n\n  return {\n    width,\n    height: count * label.font.size + ((count + 1) * label.yPadding)\n  };\n}\n\nfunction calculateLabelPosition(line, width, height, chartArea) {\n  const label = line.options.label;\n  const {xAdjust, yAdjust, xPadding, yPadding, position} = label;\n  const p1 = {x: line.x, y: line.y};\n  const p2 = {x: line.x2, y: line.y2};\n  const rotation = label.rotation === 'auto' ? calculateAutoRotation(line) : toRadians(label.rotation);\n  const size = rotatedSize(width, height, rotation);\n  const t = calculateT(line, position, size, chartArea);\n  const pt = pointInLine(p1, p2, t);\n  const xCoordinateSizes = {size: size.w, min: chartArea.left, max: chartArea.right, padding: xPadding};\n  const yCoordinateSizes = {size: size.h, min: chartArea.top, max: chartArea.bottom, padding: yPadding};\n\n  return {\n    x: adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust,\n    y: adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust,\n    width,\n    height,\n    rotation\n  };\n}\n\nfunction rotatedSize(width, height, rotation) {\n  const cos = Math.cos(rotation);\n  const sin = Math.sin(rotation);\n  return {\n    w: Math.abs(width * cos) + Math.abs(height * sin),\n    h: Math.abs(width * sin) + Math.abs(height * cos)\n  };\n}\n\nfunction calculateT(line, position, rotSize, chartArea) {\n  let t = 0.5;\n  const space = spaceAround(line, chartArea);\n  const label = line.options.label;\n  if (position === 'start') {\n    t = calculateTAdjust({w: line.x2 - line.x, h: line.y2 - line.y}, rotSize, label, space);\n  } else if (position === 'end') {\n    t = 1 - calculateTAdjust({w: line.x - line.x2, h: line.y - line.y2}, rotSize, label, space);\n  }\n  return t;\n}\n\nfunction calculateTAdjust(lineSize, labelSize, label, space) {\n  const {xPadding, yPadding} = label;\n  const lineW = lineSize.w * space.dx;\n  const lineH = lineSize.h * space.dy;\n  const x = (lineW > 0) && ((labelSize.w / 2 + xPadding - space.x) / lineW);\n  const y = (lineH > 0) && ((labelSize.h / 2 + yPadding - space.y) / lineH);\n  return clamp(Math.max(x, y), 0, 0.25);\n}\n\nfunction spaceAround(line, chartArea) {\n  const {x, x2, y, y2} = line;\n  const t = Math.min(y, y2) - chartArea.top;\n  const l = Math.min(x, x2) - chartArea.left;\n  const b = chartArea.bottom - Math.max(y, y2);\n  const r = chartArea.right - Math.max(x, x2);\n  return {\n    x: Math.min(l, r),\n    y: Math.min(t, b),\n    dx: l < r ? 1 : -1,\n    dy: t < b ? 1 : -1\n  };\n}\n\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\n  const {size, min, max, padding} = labelSizes;\n  const halfSize = size / 2;\n\n  if (size > max - min) {\n    // if it does not fit, display as much as possible\n    return (max + min) / 2;\n  }\n\n  if (min >= (coordinate - padding - halfSize)) {\n    coordinate = min + padding + halfSize;\n  }\n\n  if (max <= (coordinate + padding + halfSize)) {\n    coordinate = max - padding - halfSize;\n  }\n\n  return coordinate;\n}\n","import BoxAnnotation from './box';\n\nexport default class EllipseAnnotation extends BoxAnnotation {\n\n  inRange(x, y) {\n    return pointInEllipse({x, y}, this);\n  }\n\n  draw(ctx) {\n    const {width, height, options} = this;\n    const center = this.getCenterPoint();\n\n    ctx.save();\n\n    ctx.beginPath();\n\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n\n    ctx.ellipse(center.x, center.y, height / 2, width / 2, Math.PI / 2, 0, 2 * Math.PI);\n\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.restore();\n  }\n}\n\nEllipseAnnotation.id = 'ellipseAnnotation';\n\nEllipseAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\n\nEllipseAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nfunction pointInEllipse(p, ellipse) {\n  const {width, height} = ellipse;\n  const center = ellipse.getCenterPoint(true);\n  const xRadius = width / 2;\n  const yRadius = height / 2;\n\n  if (xRadius <= 0 || yRadius <= 0) {\n    return false;\n  }\n\n  return (Math.pow(p.x - center.x, 2) / Math.pow(xRadius, 2)) + (Math.pow(p.y - center.y, 2) / Math.pow(yRadius, 2)) <= 1.0;\n}\n","import {Element} from 'chart.js';\nimport {scaleValue} from '../helpers';\n\nexport default class PointAnnotation extends Element {\n\n  inRange(x, y) {\n    const {width, options} = this;\n    const center = this.getCenterPoint(true);\n    const radius = width / 2 + options.borderWidth;\n\n    if (radius <= 0) {\n      return false;\n    }\n\n    return (Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2)) <= Math.pow(radius, 2);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n\n  draw(ctx) {\n    const {x, y, width, options} = this;\n\n    ctx.save();\n\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n\n    ctx.beginPath();\n    ctx.arc(x, y, width / 2, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const {chartArea, scales} = chart;\n    const xScale = scales[options.xScaleID];\n    const yScale = scales[options.yScaleID];\n    let x = chartArea.width / 2;\n    let y = chartArea.height / 2;\n\n    if (xScale) {\n      x = scaleValue(xScale, options.xValue, x);\n    }\n\n    if (yScale) {\n      y = scaleValue(yScale, options.yValue, y);\n    }\n\n    return {\n      x,\n      y,\n      width: options.radius * 2,\n      height: options.radius * 2\n    };\n  }\n}\n\nPointAnnotation.id = 'pointAnnotation';\n\nPointAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  radius: 10,\n  xScaleID: 'x',\n  xValue: undefined,\n  yScaleID: 'y',\n  yValue: undefined\n};\n\nPointAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n","import {Animations, Chart, defaults} from 'chart.js';\nimport {clipArea, unclipArea, isFinite, valueOrDefault, isObject, isArray} from 'chart.js/helpers';\nimport {handleEvent, hooks, updateListeners} from './events';\nimport BoxAnnotation from './types/box';\nimport LineAnnotation from './types/line';\nimport EllipseAnnotation from './types/ellipse';\nimport PointAnnotation from './types/point';\nimport {version} from '../package.json';\n\nconst chartStates = new Map();\n\nconst annotationTypes = {\n  box: BoxAnnotation,\n  line: LineAnnotation,\n  ellipse: EllipseAnnotation,\n  point: PointAnnotation\n};\n\nObject.keys(annotationTypes).forEach(key => {\n  defaults.describe(`elements.${annotationTypes[key].id}`, {\n    _fallback: 'plugins.annotation'\n  });\n});\n\nexport default {\n  id: 'annotation',\n\n  version,\n\n  afterRegister() {\n    Chart.register(annotationTypes);\n  },\n\n  afterUnregister() {\n    Chart.unregister(annotationTypes);\n  },\n\n  beforeInit(chart) {\n    chartStates.set(chart, {\n      annotations: [],\n      elements: [],\n      listeners: {},\n      listened: false,\n      moveListened: false\n    });\n  },\n\n  beforeUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    const annotations = state.annotations = [];\n\n    let annotationOptions = options.annotations;\n    if (isObject(annotationOptions)) {\n      Object.keys(annotationOptions).forEach(key => {\n        const value = annotationOptions[key];\n        if (isObject(value)) {\n          value.id = key;\n          annotations.push(value);\n        }\n      });\n    } else if (isArray(annotationOptions)) {\n      annotations.push(...annotationOptions);\n    }\n  },\n\n  afterDataLimits(chart, args) {\n    const state = chartStates.get(chart);\n    adjustScaleRange(chart, args.scale, state.annotations.filter(a => a.display && a.adjustScaleRange));\n  },\n\n  afterUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    updateListeners(chart, state, options);\n    updateElements(chart, state, options, args.mode);\n  },\n\n  beforeDatasetsDraw(chart) {\n    draw(chart, 'beforeDatasetsDraw');\n  },\n\n  afterDatasetsDraw(chart) {\n    draw(chart, 'afterDatasetsDraw');\n  },\n\n  beforeDraw(chart) {\n    draw(chart, 'beforeDraw');\n  },\n\n  afterDraw(chart) {\n    draw(chart, 'afterDraw');\n  },\n\n  beforeEvent(chart, args, options) {\n    const state = chartStates.get(chart);\n    handleEvent(chart, state, args.event, options);\n  },\n\n  destroy(chart) {\n    chartStates.delete(chart);\n  },\n\n  _getState(chart) {\n    return chartStates.get(chart);\n  },\n\n  defaults: {\n    drawTime: 'afterDatasetsDraw',\n    dblClickSpeed: 350, // ms\n    animations: {\n      numbers: {\n        properties: ['x', 'y', 'x2', 'y2', 'width', 'height'],\n        type: 'number'\n      },\n    },\n    label: {\n      drawTime: null\n    }\n  },\n\n  descriptors: {\n    _indexable: false,\n    _scriptable: (prop) => !hooks.includes(prop),\n    annotations: {\n      _allKeys: false,\n      _fallback: (prop, opts) => `elements.${annotationTypes[opts.type || 'line'].id}`,\n    },\n  },\n\n  additionalOptionScopes: ['']\n};\n\nconst directUpdater = {\n  update: Object.assign\n};\n\nfunction resolveAnimations(chart, animOpts, mode) {\n  if (mode === 'reset' || mode === 'none' || mode === 'resize') {\n    return directUpdater;\n  }\n  return new Animations(chart, animOpts);\n}\n\nfunction updateElements(chart, state, options, mode) {\n  const animations = resolveAnimations(chart, options.animations, mode);\n\n  const annotations = state.annotations;\n  const elements = resyncElements(state.elements, annotations);\n\n  for (let i = 0; i < annotations.length; i++) {\n    const annotation = annotations[i];\n    let el = elements[i];\n    const elType = annotationTypes[annotation.type] || annotationTypes.line;\n    if (!el || !(el instanceof elType)) {\n      el = elements[i] = new elType();\n    }\n    const opts = resolveAnnotationOptions(annotation.setContext(getContext(chart, el, annotation)));\n    const properties = el.resolveElementProperties(chart, opts);\n    properties.skip = isNaN(properties.x) || isNaN(properties.y);\n    properties.options = opts;\n    animations.update(el, properties);\n  }\n}\n\nfunction resolveAnnotationOptions(resolver) {\n  const elType = annotationTypes[resolver.type] || annotationTypes.line;\n  const result = {};\n  result.id = resolver.id;\n  result.type = resolver.type;\n  result.drawTime = resolver.drawTime;\n  Object.assign(result, resolveObj(resolver, elType.defaults), resolveObj(resolver, elType.defaultRoutes));\n  for (const hook of hooks) {\n    result[hook] = resolver[hook];\n  }\n  return result;\n}\n\nfunction resolveObj(resolver, defs) {\n  const result = {};\n  for (const name of Object.keys(defs)) {\n    const optDefs = defs[name];\n    const value = resolver[name];\n    result[name] = isObject(optDefs) ? resolveObj(value, optDefs) : value;\n  }\n  return result;\n}\n\nfunction getContext(chart, element, annotation) {\n  return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\n    element,\n    id: annotation.id,\n    type: 'annotation'\n  }));\n}\n\nfunction resyncElements(elements, annotations) {\n  const count = annotations.length;\n  const start = elements.length;\n\n  if (start < count) {\n    const add = count - start;\n    elements.splice(start, 0, ...new Array(add));\n  } else if (start > count) {\n    elements.splice(count, start - count);\n  }\n  return elements;\n}\n\nfunction draw(chart, caller) {\n  const {ctx, chartArea} = chart;\n  const state = chartStates.get(chart);\n  const elements = state.elements.filter(el => !el.skip && el.options.display);\n\n  clipArea(ctx, chartArea);\n  elements.forEach(el => {\n    if (el.options.drawTime === caller) {\n      el.draw(ctx);\n    }\n  });\n  unclipArea(ctx);\n\n  elements.forEach(el => {\n    if ('drawLabel' in el && el.options.label && (el.options.label.drawTime || el.options.drawTime) === caller) {\n      el.drawLabel(ctx, chartArea);\n    }\n  });\n}\n\nfunction adjustScaleRange(chart, scale, annotations) {\n  const range = getScaleLimits(scale, annotations);\n  let changed = false;\n  if (isFinite(range.min) &&\n\t\ttypeof scale.options.min === 'undefined' &&\n\t\ttypeof scale.options.suggestedMin === 'undefined') {\n    changed = scale.min !== range.min;\n    scale.min = range.min;\n  }\n  if (isFinite(range.max) &&\n\t\ttypeof scale.options.max === 'undefined' &&\n\t\ttypeof scale.options.suggestedMax === 'undefined') {\n    changed = scale.max !== range.max;\n    scale.max = range.max;\n  }\n  if (changed && typeof scale.handleTickRangeOptions === 'function') {\n    scale.handleTickRangeOptions();\n  }\n}\n\nfunction getScaleLimits(scale, annotations) {\n  const axis = scale.axis;\n  const scaleID = scale.id;\n  const scaleIDOption = axis + 'ScaleID';\n  let min = valueOrDefault(scale.min, Number.NEGATIVE_INFINITY);\n  let max = valueOrDefault(scale.max, Number.POSITIVE_INFINITY);\n  for (const annotation of annotations) {\n    if (annotation.scaleID === scaleID) {\n      for (const prop of ['value', 'endValue']) {\n        const raw = annotation[prop];\n        if (raw) {\n          const value = scale.parse(raw);\n          min = Math.min(min, value);\n          max = Math.max(max, value);\n        }\n      }\n    } else if (annotation[scaleIDOption] === scaleID) {\n      for (const prop of [axis + 'Min', axis + 'Max', axis + 'Value']) {\n        const raw = annotation[prop];\n        if (raw) {\n          const value = scale.parse(raw);\n          min = Math.min(min, value);\n          max = Math.max(max, value);\n        }\n      }\n    }\n  }\n  return {min, max};\n}\n","import {Chart} from 'chart.js';\nimport Annotation from './annotation';\n\nChart.register(Annotation);\n\nexport default Annotation;\n"],"names":["clickHooks","moveHooks","hooks","concat","handleEvent","chart","state","event","options","listened","type","moveListened","element","getNearestItem","elements","previous","hovered","dispatchEvent","leave","listeners","enter","dispatchMoveEvents","handleMoveEvents","elOpts","dblclick","click","clickTimeout","clearTimeout","setTimeout","dblClickSpeed","handleClickEvents","_state","handler","callHandler","position","minDistance","Number","POSITIVE_INFINITY","filter","display","inRange","x","y","reduce","nearestItems","center","getCenterPoint","distance","distanceBetweenPoints","push","sort","a","b","_index","slice","PI","Math","HALF_PI","scaleValue","scale","value","fallback","parse","isFinite","getPixelForValue","roundedRect","ctx","width","height","radius","beginPath","r","min","left","top","right","bottom","moveTo","arc","closePath","rect","BoxAnnotation","Element","[object Object]","mouseX","mouseY","useFinalPosition","this","getProps","save","lineWidth","borderWidth","strokeStyle","borderColor","fillStyle","backgroundColor","setLineDash","borderDash","lineDashOffset","borderDashOffset","cornerRadius","fill","stroke","restore","xScale","scales","xScaleID","yScale","yScaleID","max","y2","x2","chartArea","xMin","xMax","yMin","yMax","id","defaults","adjustScaleRange","undefined","defaultRoutes","clamp","from","to","pointInLine","p1","p2","t","interpolateX","abs","interpolateY","limitPointToArea","NaN","LineAnnotation","epsilon","me","dy","dx","label","enabled","content","labelRect","point","angle","rotation","cos","sin","cx","cy","w2","h2","intersects","isOnLabel","lineTo","labelIsVisible","line","font","toFontString","Image","getImageSize","xPadding","yPadding","lines","isArray","count","length","i","text","widthCache","has","set","measureText","get","size","measureLabel","xAdjust","yAdjust","atan2","calculateAutoRotation","toRadians","w","h","rotatedSize","rotSize","space","l","spaceAround","calculateTAdjust","calculateT","pt","xCoordinateSizes","padding","yCoordinateSizes","adjustLabelCoordinate","calculateLabelPosition","translate","rotate","color","textAlign","calculateLabelXAlignment","textYPosition","textBaseline","fillText","drawImage","drawLabel","scaleID","endValue","isHorizontal","area","limitLineToArea","s","endsWith","parseFloat","drawTime","family","lineHeight","style","weight","Map","lineSize","labelSize","lineW","lineH","coordinate","labelSizes","halfSize","EllipseAnnotation","p","ellipse","xRadius","yRadius","pow","pointInEllipse","PointAnnotation","xValue","yValue","chartStates","annotationTypes","box","Object","keys","forEach","key","describe","_fallback","version","Chart","register","unregister","annotations","args","annotationOptions","isObject","range","axis","scaleIDOption","valueOrDefault","NEGATIVE_INFINITY","annotation","prop","raw","getScaleLimits","changed","suggestedMin","suggestedMax","handleTickRangeOptions","hook","scope","updateListeners","mode","animations","animOpts","directUpdater","Animations","resolveAnimations","start","add","splice","Array","resyncElements","el","elType","opts","resolveAnnotationOptions","setContext","getContext","properties","resolveElementProperties","skip","isNaN","update","updateElements","draw","delete","_getState","numbers","descriptors","_indexable","_scriptable","includes","_allKeys","additionalOptionScopes","assign","resolver","result","resolveObj","defs","name","optDefs","$context","create","caller","clipArea","unclipArea","Annotation"],"mappings":"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"}