{"version":3,"sources":["js\\element-internals-polyfill.js"],"names":["refMap","WeakMap","validityMap","hiddenInputMap","internalsMap","validationMessageMap","formsMap","shadowHostsMap","formElementsMap","refValueMap","upgradeMap","shadowRootMap","validationAnchorMap","documentFragmentMap","onSubmitMap","observerConfig$1","attributes","attributeFilter","observer","MutationObserver","mutationsList","mutation","target","constructor","formDisabledCallback","apply","hasAttribute","removeHiddenInputs","internals","get","forEach","hiddenInput","remove","set","createHiddenInput","ref","input","document","createElement","type","name","getAttribute","after","push","initLabels","labels","length","Array","from","label","addEventListener","focus","bind","firstLabelId","id","htmlFor","setAttribute","formSubmitCallback","event","form","elements","size","reverse","map","node","reportValidity","includes","stopImmediatePropagation","stopPropagation","preventDefault","call","formResetCallback","element","formAssociated","initForm","onsubmit","formElements","add","initSet","Set","formAssociatedCallback","setTimeout","findParentForm","elem","parent","parentNode","tagName","toString","host","throwIfNotFormAssociated","message","ErrorType","DOMException","overrideFormMethod","returnValue","method","upgradeInternals","aom","ariaAtomic","ariaAutoComplete","ariaBusy","ariaChecked","ariaColCount","ariaColIndex","ariaColSpan","ariaCurrent","ariaDisabled","ariaExpanded","ariaHasPopup","ariaHidden","ariaKeyShortcuts","ariaLabel","ariaLevel","ariaLive","ariaModal","ariaMultiLine","ariaMultiSelectable","ariaOrientation","ariaPlaceholder","ariaPosInSet","ariaPressed","ariaReadOnly","ariaRelevant","ariaRequired","ariaRoleDescription","ariaRowCount","ariaRowIndex","ariaRowSpan","ariaSelected","ariaSort","ariaValueMax","ariaValueMin","ariaValueNow","ariaValueText","ValidityState","this","badInput","customError","patternMismatch","rangeOverflow","rangeUnderflow","stepMismatch","tooLong","tooShort","typeMismatch","valid","valueMissing","Object","seal","isValid","validityState","key","observerCallback","mutationList","mutationRecord","addedNodes","removedNodes","added","removed","has","keys","filter","delete","disconnect","fragmentObserverCallback","observerConfig","childList","subtree","customStateMap","CustomStateSet","super","indexOf","TypeError","state","exec","result","toggleAttribute","clear","entry","entries","ElementInternals","rootNode","getRootNode","validity","states","closureValue","attributeName","defineProperty","value","isConnected","initAom","observe","initRef","DocumentFragment","fragment","deferUpgrade","isPolyfilled","checkValidity","validityEvent","Event","bubbles","cancelable","composed","dispatchEvent","hostRoot","querySelectorAll","anchor","setFormValue","FormData","formDataValue","formDataKey","setValidity","validityChanges","validationMessage","validityChangesObj","validityObject","check","newState","reconcileValidty","shadowRoot","willValidate","disabled","window","attachShadowObserver","args","attachShadow","checkValidityOverride","reportValidityOverride","Element","prototype","Error","documentElement","HTMLFormElement"],"mappings":"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","sourcesContent":["(function () {\n    'use strict';\n\n    const refMap = new WeakMap();\n    const validityMap = new WeakMap();\n    const hiddenInputMap = new WeakMap();\n    const internalsMap = new WeakMap();\n    const validationMessageMap = new WeakMap();\n    const formsMap = new WeakMap();\n    const shadowHostsMap = new WeakMap();\n    const formElementsMap = new WeakMap();\n    const refValueMap = new WeakMap();\n    const upgradeMap = new WeakMap();\n    const shadowRootMap = new WeakMap();\n    const validationAnchorMap = new WeakMap();\n    const documentFragmentMap = new WeakMap();\n    const onSubmitMap = new WeakMap();\n\n    const observerConfig$1 = { attributes: true, attributeFilter: ['disabled'] };\n    const observer = new MutationObserver((mutationsList) => {\n        for (const mutation of mutationsList) {\n            const target = mutation.target;\n            if (target.constructor['formAssociated']) {\n                if (target.formDisabledCallback) {\n                    target.formDisabledCallback.apply(target, [target.hasAttribute('disabled')]);\n                }\n            }\n        }\n    });\n    const removeHiddenInputs = (internals) => {\n        const hiddenInputs = hiddenInputMap.get(internals);\n        hiddenInputs.forEach(hiddenInput => {\n            hiddenInput.remove();\n        });\n        hiddenInputMap.set(internals, []);\n    };\n    const createHiddenInput = (ref, internals) => {\n        const input = document.createElement('input');\n        input.type = 'hidden';\n        input.name = ref.getAttribute('name');\n        ref.after(input);\n        hiddenInputMap.get(internals).push(input);\n        return input;\n    };\n    const initRef = (ref, internals) => {\n        hiddenInputMap.set(internals, []);\n        observer.observe(ref, observerConfig$1);\n    };\n    const initLabels = (ref, labels) => {\n        if (labels.length) {\n            Array.from(labels).forEach(label => label.addEventListener('click', ref.focus.bind(ref)));\n            let firstLabelId = labels[0].id;\n            if (!labels[0].id) {\n                firstLabelId = `${labels[0].htmlFor}_Label`;\n                labels[0].id = firstLabelId;\n            }\n            ref.setAttribute('aria-labelledby', firstLabelId);\n        }\n    };\n    const formSubmitCallback = (event) => {\n        const form = event.target;\n        const elements = formElementsMap.get(form);\n        if (elements.size) {\n            const nodes = Array.from(elements);\n            const validityList = nodes\n                .reverse()\n                .map(node => {\n                const internals = internalsMap.get(node);\n                return internals.reportValidity();\n            });\n            if (validityList.includes(false)) {\n                event.stopImmediatePropagation();\n                event.stopPropagation();\n                event.preventDefault();\n            }\n            else if (onSubmitMap.get(form)) {\n                const callback = onSubmitMap.get(form);\n                const canceled = callback.call(form, event);\n                if (canceled === false) {\n                    event.preventDefault();\n                }\n            }\n        }\n    };\n    const formResetCallback = (event) => {\n        const elements = formElementsMap.get(event.target);\n        if (elements && elements.size) {\n            elements.forEach(element => {\n                if (element.constructor.formAssociated && element.formResetCallback) {\n                    element.formResetCallback.apply(element);\n                }\n            });\n        }\n    };\n    const initForm = (ref, form, internals) => {\n        if (form) {\n            if (form.onsubmit) {\n                onSubmitMap.set(form, form.onsubmit.bind(form));\n                form.onsubmit = null;\n            }\n            const formElements = formElementsMap.get(form);\n            if (formElements) {\n                formElements.add(ref);\n            }\n            else {\n                const initSet = new Set();\n                initSet.add(ref);\n                formElementsMap.set(form, initSet);\n                form.addEventListener('submit', formSubmitCallback);\n                form.addEventListener('reset', formResetCallback);\n            }\n            formsMap.set(form, { ref, internals });\n            if (ref.constructor['formAssociated'] && ref.formAssociatedCallback) {\n                setTimeout(() => {\n                    ref.formAssociatedCallback.apply(ref, [form]);\n                }, 0);\n            }\n        }\n    };\n    const findParentForm = (elem) => {\n        let parent = elem.parentNode;\n        if (parent && parent.tagName !== 'FORM') {\n            parent = findParentForm(parent);\n        }\n        else if (!parent && elem.toString() === '[object ShadowRoot]') {\n            parent = findParentForm(elem.host);\n        }\n        return parent;\n    };\n    const throwIfNotFormAssociated = (ref, message, ErrorType = DOMException) => {\n        if (!ref.constructor['formAssociated']) {\n            throw new ErrorType(message);\n        }\n    };\n    const overrideFormMethod = (form, returnValue, method) => {\n        const elements = formElementsMap.get(form);\n        if (elements && elements.size) {\n            elements.forEach(element => {\n                const internals = internalsMap.get(element);\n                const valid = internals[method]();\n                if (!valid) {\n                    returnValue = false;\n                }\n            });\n        }\n        return returnValue;\n    };\n    const upgradeInternals = (ref) => {\n        if (ref.constructor['formAssociated']) {\n            const internals = internalsMap.get(ref);\n            const { labels, form } = internals;\n            initLabels(ref, labels);\n            initForm(ref, form, internals);\n        }\n    };\n\n    const aom = {\n        ariaAtomic: 'aria-atomic',\n        ariaAutoComplete: 'aria-autocomplete',\n        ariaBusy: 'aria-busy',\n        ariaChecked: 'aria-checked',\n        ariaColCount: 'aria-colcount',\n        ariaColIndex: 'aria-colindex',\n        ariaColSpan: 'aria-colspan',\n        ariaCurrent: 'aria-current',\n        ariaDisabled: 'aria-disabled',\n        ariaExpanded: 'aria-expanded',\n        ariaHasPopup: 'aria-haspopup',\n        ariaHidden: 'aria-hidden',\n        ariaKeyShortcuts: 'aria-keyshortcuts',\n        ariaLabel: 'aria-label',\n        ariaLevel: 'aria-level',\n        ariaLive: 'aria-live',\n        ariaModal: 'aria-modal',\n        ariaMultiLine: 'aria-multiline',\n        ariaMultiSelectable: 'aria-multiselectable',\n        ariaOrientation: 'aria-orientation',\n        ariaPlaceholder: 'aria-placeholder',\n        ariaPosInSet: 'aria-posinset',\n        ariaPressed: 'aria-pressed',\n        ariaReadOnly: 'aria-readonly',\n        ariaRelevant: 'aria-relevant',\n        ariaRequired: 'aria-required',\n        ariaRoleDescription: 'aria-roledescription',\n        ariaRowCount: 'aria-rowcount',\n        ariaRowIndex: 'aria-rowindex',\n        ariaRowSpan: 'aria-rowspan',\n        ariaSelected: 'aria-selected',\n        ariaSort: 'aria-sort',\n        ariaValueMax: 'aria-valuemax',\n        ariaValueMin: 'aria-valuemin',\n        ariaValueNow: 'aria-valuenow',\n        ariaValueText: 'aria-valuetext'\n    };\n    const initAom = (ref, internals) => {\n        for (let key in aom) {\n            internals[key] = null;\n            let closureValue = null;\n            const attributeName = aom[key];\n            Object.defineProperty(internals, key, {\n                get() {\n                    return closureValue;\n                },\n                set(value) {\n                    closureValue = value;\n                    if (ref.isConnected) {\n                        ref.setAttribute(attributeName, value);\n                    }\n                    else {\n                        upgradeMap.set(ref, internals);\n                    }\n                }\n            });\n        }\n    };\n\n    class ValidityState {\n        constructor() {\n            this.badInput = false;\n            this.customError = false;\n            this.patternMismatch = false;\n            this.rangeOverflow = false;\n            this.rangeUnderflow = false;\n            this.stepMismatch = false;\n            this.tooLong = false;\n            this.tooShort = false;\n            this.typeMismatch = false;\n            this.valid = true;\n            this.valueMissing = false;\n            Object.seal(this);\n        }\n    }\n    const setValid = (validityObject) => {\n        validityObject.badInput = false;\n        validityObject.customError = false;\n        validityObject.patternMismatch = false;\n        validityObject.rangeOverflow = false;\n        validityObject.rangeUnderflow = false;\n        validityObject.stepMismatch = false;\n        validityObject.tooLong = false;\n        validityObject.tooShort = false;\n        validityObject.typeMismatch = false;\n        validityObject.valid = true;\n        validityObject.valueMissing = false;\n        return validityObject;\n    };\n    const reconcileValidty = (validityObject, newState) => {\n        validityObject.valid = isValid(newState);\n        Object.keys(newState).forEach(key => validityObject[key] = newState[key]);\n        return validityObject;\n    };\n    const isValid = (validityState) => {\n        let valid = true;\n        for (let key in validityState) {\n            if (key !== 'valid' && validityState[key] !== false) {\n                valid = false;\n            }\n        }\n        return valid;\n    };\n\n    function observerCallback(mutationList) {\n        mutationList.forEach(mutationRecord => {\n            const { addedNodes, removedNodes } = mutationRecord;\n            const added = Array.from(addedNodes);\n            const removed = Array.from(removedNodes);\n            added.forEach(node => {\n                if (internalsMap.has(node) && node.constructor['formAssociated']) {\n                    const internals = internalsMap.get(node);\n                    const { form } = internals;\n                    initForm(node, form, internals);\n                    initLabels(node, internals.labels);\n                }\n                if (upgradeMap.has(node)) {\n                    const internals = upgradeMap.get(node);\n                    const aomKeys = Object.keys(aom);\n                    aomKeys\n                        .filter(key => internals[key] !== null)\n                        .forEach(key => {\n                        node.setAttribute(aom[key], internals[key]);\n                    });\n                    upgradeMap.delete(node);\n                }\n            });\n            removed.forEach(node => {\n                const internals = internalsMap.get(node);\n                if (internals && hiddenInputMap.get(internals)) {\n                    removeHiddenInputs(internals);\n                }\n                if (shadowHostsMap.has(node)) {\n                    const observer = shadowHostsMap.get(node);\n                    observer.disconnect();\n                }\n            });\n        });\n    }\n    function fragmentObserverCallback(mutationList) {\n        mutationList.forEach(mutation => {\n            const { removedNodes } = mutation;\n            removedNodes.forEach(node => {\n                const observer = documentFragmentMap.get(mutation.target);\n                if (internalsMap.has(node)) {\n                    upgradeInternals(node);\n                }\n                observer.disconnect();\n            });\n        });\n    }\n    const deferUpgrade = (fragment) => {\n        const observer = new MutationObserver(fragmentObserverCallback);\n        observer.observe(fragment, { childList: true });\n        documentFragmentMap.set(fragment, observer);\n    };\n    new MutationObserver(observerCallback);\n    const observerConfig = {\n        childList: true,\n        subtree: true\n    };\n\n    const customStateMap = new WeakMap();\n    class CustomStateSet extends Set {\n        constructor(ref) {\n            super();\n            if (!ref || !ref.tagName || ref.tagName.indexOf('-') === -1) {\n                throw new TypeError('Illegal constructor');\n            }\n            customStateMap.set(this, ref);\n        }\n        add(state) {\n            if (!/^--/.exec(state) || typeof state !== 'string') {\n                throw new DOMException(`Failed to execute 'add' on 'CustomStateSet': The specified value ${state} must start with '--'.`);\n            }\n            const result = super.add(state);\n            const ref = customStateMap.get(this);\n            ref.toggleAttribute(`state${state}`, true);\n            return result;\n        }\n        clear() {\n            for (let [entry] of this.entries()) {\n                this.delete(entry);\n            }\n            super.clear();\n        }\n        delete(state) {\n            const result = super.delete(state);\n            const ref = customStateMap.get(this);\n            ref.toggleAttribute(`state${state}`, false);\n            return result;\n        }\n    }\n\n    class ElementInternals {\n        constructor(ref) {\n            if (!ref || !ref.tagName || ref.tagName.indexOf('-') === -1) {\n                throw new TypeError('Illegal constructor');\n            }\n            const rootNode = ref.getRootNode();\n            const validity = new ValidityState();\n            this.states = new CustomStateSet(ref);\n            refMap.set(this, ref);\n            validityMap.set(this, validity);\n            internalsMap.set(ref, this);\n            initAom(ref, this);\n            initRef(ref, this);\n            Object.seal(this);\n            upgradeInternals(ref);\n            if (rootNode instanceof DocumentFragment) {\n                deferUpgrade(rootNode);\n            }\n        }\n        static get isPolyfilled() {\n            return true;\n        }\n        checkValidity() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to execute 'checkValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);\n            const validity = validityMap.get(this);\n            if (!validity.valid) {\n                const validityEvent = new Event('invalid', {\n                    bubbles: false,\n                    cancelable: true,\n                    composed: false\n                });\n                ref.dispatchEvent(validityEvent);\n            }\n            return validity.valid;\n        }\n        get form() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to read the 'form' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n            let form;\n            if (ref.constructor['formAssociated'] === true) {\n                form = findParentForm(ref);\n            }\n            return form;\n        }\n        get labels() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to read the 'labels' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n            const id = ref.getAttribute('id');\n            const hostRoot = ref.getRootNode();\n            if (hostRoot && id) {\n                return hostRoot ? hostRoot.querySelectorAll(`[for='${id}']`) : []; //***\n            }\n            return [];\n        }\n        reportValidity() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to execute 'reportValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);\n            const valid = this.checkValidity();\n            const anchor = validationAnchorMap.get(this);\n            if (anchor && !ref.constructor['formAssociated']) {\n                throw new DOMException(`Failed to execute 'setValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);\n            }\n            if (!valid && anchor) {\n                ref.focus();\n                anchor.focus();\n            }\n            return valid;\n        }\n        setFormValue(value) {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to execute 'setFormValue' on 'ElementInternals': The target element is not a form-associated custom element.`);\n            removeHiddenInputs(this);\n            if (value != null && !(value instanceof FormData)) {\n                if (ref.getAttribute('name')) {\n                    const hiddenInput = createHiddenInput(ref, this);\n                    hiddenInput.value = value;\n                }\n            }\n            else if (value != null && value instanceof FormData) {\n                value.forEach((formDataValue, formDataKey) => {\n                    if (typeof formDataValue === 'string') {\n                        const hiddenInput = createHiddenInput(ref, this);\n                        hiddenInput.name = formDataKey;\n                        hiddenInput.value = formDataValue;\n                    }\n                });\n            }\n            refValueMap.set(ref, value);\n        }\n        setValidity(validityChanges, validationMessage, anchor) {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to execute 'setValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);\n            if (!validityChanges) {\n                throw new TypeError('Failed to execute \\'setValidity\\' on \\'ElementInternals\\': 1 argument required, but only 0 present.');\n            }\n            validationAnchorMap.set(this, anchor);\n            const validity = validityMap.get(this);\n            const validityChangesObj = {};\n            for (const key in validityChanges) {\n                validityChangesObj[key] = validityChanges[key];\n            }\n            if (Object.keys(validityChangesObj).length === 0) {\n                setValid(validity);\n            }\n            const check = { ...validity, ...validityChangesObj };\n            delete check.valid;\n            const { valid } = reconcileValidty(validity, check);\n            if (!valid && !validationMessage) {\n                throw new DOMException(`Failed to execute 'setValidity' on 'ElementInternals': The second argument should not be empty if one or more flags in the first argument are true.`);\n            }\n            validationMessageMap.set(this, valid ? '' : validationMessage);\n            ref.toggleAttribute('internals-invalid', !valid);\n            ref.toggleAttribute('internals-valid', valid);\n            ref.setAttribute('aria-invalid', `${!valid}`);\n        }\n        get shadowRoot() {\n            const ref = refMap.get(this);\n            const shadowRoot = shadowRootMap.get(ref);\n            if (shadowRoot) {\n                return shadowRootMap.get(ref);\n            }\n            return null;\n        }\n        get validationMessage() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to read the 'validationMessage' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n            return validationMessageMap.get(this);\n        }\n        get validity() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to read the 'validity' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n            const validity = validityMap.get(this);\n            return validity;\n        }\n        get willValidate() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to read the 'willValidate' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n            if (ref.disabled || ref.hasAttribute('disabled')) {\n                return false;\n            }\n            return true;\n        }\n    }\n    if (!window.CustomStateSet) {\n        window.CustomStateSet = CustomStateSet;\n    }\n    if (!window.ElementInternals) {\n        window.ElementInternals = ElementInternals;\n        function attachShadowObserver(...args) {\n            const shadowRoot = attachShadow.apply(this, args);\n            const observer = new MutationObserver(observerCallback);\n            shadowRootMap.set(this, shadowRoot);\n            observer.observe(shadowRoot, observerConfig);\n            shadowHostsMap.set(this, observer);\n            return shadowRoot;\n        }\n        function checkValidityOverride(...args) {\n            let returnValue = checkValidity.apply(this, args);\n            return overrideFormMethod(this, returnValue, 'checkValidity');\n        }\n        function reportValidityOverride(...args) {\n            let returnValue = reportValidity.apply(this, args);\n            return overrideFormMethod(this, returnValue, 'reportValidity');\n        }\n        Object.defineProperty(Element.prototype, 'attachInternals', {\n            get() {\n                return () => {\n                    if (this.tagName.indexOf('-') === -1) {\n                        throw new Error(`Failed to execute 'attachInternals' on 'HTMLElement': Unable to attach ElementInternals to non-custom elements.`);\n                    }\n                    return new ElementInternals(this);\n                };\n            }\n        });\n        const attachShadow = Element.prototype.attachShadow;\n        Element.prototype.attachShadow = attachShadowObserver;\n        const documentObserver = new MutationObserver(observerCallback);\n        documentObserver.observe(document.documentElement, observerConfig);\n        const checkValidity = HTMLFormElement.prototype.checkValidity;\n        HTMLFormElement.prototype.checkValidity = checkValidityOverride;\n        const reportValidity = HTMLFormElement.prototype.reportValidity;\n        HTMLFormElement.prototype.reportValidity = reportValidityOverride;\n    }\n\n}());\n"]}